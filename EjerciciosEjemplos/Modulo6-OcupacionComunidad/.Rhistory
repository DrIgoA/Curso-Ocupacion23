xlim = c(-1, 25), ylim = c(0, 140), cex = 1.5, lwd = 2, frame.plot = FALSE,
las = 1, pch = 16, xlab = "Length", ylab = "Mass")
# Fit fixed-effects model, print regression parameter estimates and plot regression lines
summary(lm <- lm(mass ~ pop-1 + length))
abline(lm$coef[1], lm$coef[4], col = "red", lwd = 3, lty = 2)
abline(lm$coef[2], lm$coef[4], col = "blue", lwd = 3, lty = 2)
abline(lm$coef[3], lm$coef[4], col = "green", lwd = 3, lty = 2)
library(lme4)
# Fit mixed model, print random effects and plot regression lines
summary(lmm <- lmer(mass ~ length + (1|pop)))  #pop is the random effect
#and is itercept
ranef(lmm)
abline((lmm@fixef[1]+ranef(lmm)$pop)[1,], lmm@fixef[2], col = "red", lwd = 3)
abline((lmm@fixef[1]+ranef(lmm)$pop)[2,], lmm@fixef[2], col = "blue", lwd = 3)
abline((lmm@fixef[1]+ranef(lmm)$pop)[3,], lmm@fixef[2], col = "green", lwd = 3)
str(lmm)
#and is itercept
ranef(lmm)
fixef(lmm)
fixef(lmm[1])
fixef(lmm)[1]
#and is itercept
ranef(lmm)
abline((fixef(lmm)[1]+ranef(lmm)$pop)[1,], fixef(lmm)[2], col = "red", lwd = 3)
abline((fixef(lmm)[1]+ranef(lmm)$pop)[2,], fixef(lmm)[2], col = "blue", lwd = 3)
abline((fixef(lmm)[1]+ranef(lmm)$pop)[3,], fixef(lmm)[2], col = "green", lwd = 3)
# 4.3. Mixed models with random effects for variability among groups (site and year effects)
# 4.3.1. Generation and analysis of simulated data
data.fn <- function(nsite = 5, nyear = 20, alpha = 4.18456, beta1 = 1.90672, beta2 = 0.10852, beta3 = -1.17121, sd.site = 0.5, sd.year = 0.2){
# nsite: Number of populations
# nyear: Number of years
# alpha, beta1, beta2, beta3: cubic polynomial coefficients of year
# sd.site: standard deviation of the normal distribution assumed for the population intercepts alpha
# sd.year: standard deviation of the normal distribution assumed for the year effects
# We standardize the year covariate so that it runs from about 1 to 1
# Generate data structure to hold counts and log(lambda)
C <- log.expected.count <- array(NA, dim = c(nyear, nsite))
# Generate covariate values
year <- 1:nyear
yr <- (year-20)/20	# Standardize
site <- 1:nsite
# Draw two sets of random effects from their respective distribution
alpha.site <- rnorm(n = nsite, mean = alpha, sd = sd.site)
eps.year <- rnorm(n = nyear, mean = 0, sd = sd.year)
# Loop over populations
for (j in 1:nsite){
# Signal (plus first level of noise): build up systematic part of the GLM including random site and year effects
log.expected.count[,j] <- alpha.site[j] + beta1 * yr + beta2 * yr^2 + beta3 * yr^3 + eps.year
expected.count <- exp(log.expected.count[,j])
# Second level of noise: generate random part of the GLM: Poisson noise around expected counts
C[,j] <- rpois(n = nyear, lambda = expected.count)
}
# Plot simulated data
matplot(year, C, type = "l", lty = 1, lwd = 2, main = "", las = 1, ylab = "Population size", xlab = "Year")
return(list(nsite = nsite, nyear = nyear, alpha.site = alpha.site, beta1 = beta1, beta2 = beta2, beta3 = beta3, year = year, sd.site = sd.site, sd.year = sd.year, expected.count = expected.count, C = C))
}
data <- data.fn(nsite = 5, nyear = 20, sd.site = 0.3, sd.year = 0.2)
# Specify model in BUGS language
sink("GLMM_Poisson.txt")
cat("
model {
# Priors
for (j in 1:nsite){
alpha[j] ~ dnorm(mu, tau.alpha)		# 4. Random site effects
}
mu ~ dnorm(0, 0.01)				# Hyperparameter 1
tau.alpha <- 1 / (sd.alpha*sd.alpha)	        # Hyperparameter 2
sd.alpha ~ dunif(0, 2)
for (p in 1:3){
beta[p] ~ dnorm(0, 0.01)
}
tau.year <- 1 / (sd.year*sd.year)
sd.year ~ dunif(0, 1)				# Hyperparameter 3
# Likelihood
for (i in 1:nyear){
eps[i] ~ dnorm(0, tau.year)                # 4. Random year effects
for (j in 1:nsite){
C[i,j] ~ dpois(lambda[i,j])             # 1. Distribution for random part
lambda[i,j] <- exp(log.lambda[i,j])     # 2. Link function
log.lambda[i,j] <- alpha[j] + beta[1] * year[i] + beta[2] * pow(year[i],2) + beta[3] * pow(year[i],3) + eps[i]    # 3. Linear predictor including random site and random year effects
}  #j
}  #i
}
",fill = TRUE)
sink()
# Bundle data
win.data <- list(C = data$C, nsite = ncol(data$C), nyear = nrow(data$C), year = (data$year-20) / 20) # Note year standardized
# Initial values
inits <- function() list(mu = runif(1, 0, 2), alpha = runif(data$nsite, -1, 1), beta = runif(3, -1, 1), sd.alpha = runif(1, 0, 0.1), sd.year = runif(1, 0, 0.1))
# Parameters monitored (may want to add "lambda")
params <- c("mu", "alpha", "beta", "sd.alpha", "sd.year")
# MCMC settings (may have to adapt)
ni <- 50000
nt <- 5
nb <- 20000
nc <- 3
# Call WinBUGS from R (BRT 98 min)
out <- jags(win.data, inits, params, "GLMM_Poisson.txt", n.chains = nc,
n.thin = nt, n.iter = ni, n.burnin = nb)
# Summarize posteriors
print(out, dig = 3)
# Parameters monitored (may want to add "lambda")
params <- c("mu", "alpha", "beta", "sd.alpha", "sd.year", "lambda")
# Call WinBUGS from R (BRT 98 min)
out <- jags(win.data, inits, params, "GLMM_Poisson.txt", n.chains = nc,
n.thin = nt, n.iter = ni, n.burnin = nb)
# Summarize posteriors
print(out, dig = 3)
plot(data$year, out$mean$lambda[,1])
out$mean$lambda[,1]
plot(data$year, out$mean$lambda[,1], col="red")
plot(data$year, out$mean$lambda[,1], lty=1, col="red")
plot(data$year, out$mean$lambda[,1], lty=2, col="red")
plot(data$year, out$mean$lambda[,1], type=1, lty=1, col="red")
plot(data$year, out$mean$lambda[,1], type="l", lty=1, col="red")
plot(data$year, out$mean$lambda[,1], type="l", lty=1, col="red", lwd=2)
lines(data$year, out$mean$lambda[,2], type="l", lty=1, col="purple", lwd=2)
lines(data$year, out$mean$lambda[,2], type="l", lty=1, col="blue", lwd=2)
lines(data$year, out$mean$lambda[,3], type="l", lty=1, col="blue", lwd=2)
lines(data$year, out$mean$lambda[,4], type="l", lty=1, col="blue", lwd=2)
lines(data$year, out$mean$lambda[,4], type="l", lty=1, col="green", lwd=2)
lines(data$year, out$mean$lambda[,5], type="l", lty=1, col="black", lwd=2)
# Summarize posteriors
print(out, dig = 3)
data <- data.fn(nsite = 5, nyear = 20, sd.site = 0.3, sd.year = 0.2)
# Specify model in BUGS language
sink("GLMM_Poisson.txt")
cat("
model {
# Priors
for (j in 1:nsite){
alpha[j] ~ dnorm(mu, tau.alpha)		# 4. Random site effects
}
mu ~ dnorm(0, 0.01)				# Hyperparameter 1
tau.alpha <- 1 / (sd.alpha*sd.alpha)	        # Hyperparameter 2
sd.alpha ~ dunif(0, 2)
for (p in 1:2){
beta[p] ~ dnorm(0, 0.01)
}
tau.year <- 1 / (sd.year*sd.year)
sd.year ~ dunif(0, 1)				# Hyperparameter 3
# Likelihood
for (i in 1:nyear){
eps[i] ~ dnorm(0, tau.year)                # 4. Random year effects
for (j in 1:nsite){
C[i,j] ~ dpois(lambda[i,j])             # 1. Distribution for random part
lambda[i,j] <- exp(log.lambda[i,j])     # 2. Link function
log.lambda[i,j] <- alpha[i,j] + beta[1] * year[i] + beta[2] * pow(year[i],2)    # 3. Linear predictor including random site and random year effects
}  #j
}  #i
}
",fill = TRUE)
sink()
# Bundle data
win.data <- list(C = data$C, nsite = ncol(data$C), nyear = nrow(data$C), year = (data$year-20) / 20) # Note year standardized
# Initial values
inits <- function() list(mu = runif(1, 0, 2), alpha = runif(data$nsite, -1, 1), beta = runif(3, -1, 1), sd.alpha = runif(1, 0, 0.1), sd.year = runif(1, 0, 0.1))
# Parameters monitored (may want to add "lambda")
params <- c("mu", "alpha", "beta", "sd.alpha", "sd.year", "lambda")
# MCMC settings (may have to adapt)
ni <- 50000
nt <- 5
nb <- 20000
nc <- 3
# Call WinBUGS from R (BRT 98 min)
out <- jags(win.data, inits, params, "GLMM_Poisson.txt", n.chains = nc,
n.thin = nt, n.iter = ni, n.burnin = nb)
# Initial values
inits <- function() list(mu = runif(1, 0, 2), alpha = runif(data$nsite, -1, 1), beta = runif(2, -1, 1), sd.alpha = runif(1, 0, 0.1), sd.year = runif(1, 0, 0.1))
# Parameters monitored (may want to add "lambda")
params <- c("mu", "alpha", "beta", "sd.alpha", "sd.year", "lambda")
# MCMC settings (may have to adapt)
ni <- 50000
nt <- 5
nb <- 20000
nc <- 3
# Call WinBUGS from R (BRT 98 min)
out <- jags(win.data, inits, params, "GLMM_Poisson.txt", n.chains = nc,
n.thin = nt, n.iter = ni, n.burnin = nb)
plot(data$year, out$mean$lambda[,1], type="l", lty=1, col="red", lwd=2)
lines(data$year, out$mean$lambda[,2], type="l", lty=1, col="purple", lwd=2)
lines(data$year, out$mean$lambda[,3], type="l", lty=1, col="blue", lwd=2)
lines(data$year, out$mean$lambda[,4], type="l", lty=1, col="green", lwd=2)
lines(data$year, out$mean$lambda[,5], type="l", lty=1, col="black", lwd=2)
# 3.4.1 Random effects for a normal data distribution: normal-normal generalised linear mixed model (GLMM)
# ------------------------------------------------------------------------
# Plot data without distinguishing sex
plot(body, wing, col = rep(c("red", "blue", "green"), each = 3), xlim = c(6.5, 9.5),
ylim = c(10, 14), cex = 1.5, lwd = 2, frame.plot = FALSE, las = 1, pch = 16,
xlab = "Body length", ylab = "Wing span")
# Define data
pop <- factor(c(rep("Navarra", 3), rep("Aragon", 3), rep("Catalonia", 3)),
levels = c("Navarra", "Aragon", "Catalonia"))         # Population
wing <- c(10.5, 10.6, 11.0, 12.1, 11.7, 13.5, 11.4, 13.0, 12.9) # Wing span
body <- c(6.8, 8.3, 9.2, 6.9, 7.7, 8.9, 6.9, 8.2, 9.2) # Body length
sex <- factor(c("M","F","M","F","M","F","M","F","M"), levels = c("M", "F"))
mites <- c(0, 3, 2, 1, 0, 7, 0, 9, 6)      # Number of ectoparasites
color <- c(0.45, 0.47, 0.54, 0.42, 0.54, 0.46, 0.49, 0.42, 0.57) # Color intensity
damage <- c(0,2,0,0,4,2,1,0,1)                 # Number of wings damaged
# Plot data without distinguishing sex
plot(body, wing, col = rep(c("red", "blue", "green"), each = 3), xlim = c(6.5, 9.5),
ylim = c(10, 14), cex = 1.5, lwd = 2, frame.plot = FALSE, las = 1, pch = 16,
xlab = "Body length", ylab = "Wing span")
summary(lm <- lm(wing ~ pop-1 + body))     # Same as fm2
library(lme4)
summary(lmm1 <- lmer(wing ~ (1|pop) + body))  # Fit the model
ranef(lmm1)                                   # Print random effects
alpha_j <- fixef(lmm1)[1]+ranef(lmm1)$pop[,1]
cbind(fixed = coef(lm)[1:3], random = alpha_j)
op <- par(lwd = 3)
abline(lm$coef[1], lm$coef[4], col = "red", lty = 2)
abline(lm$coef[2], lm$coef[4], col = "blue", lty = 2)
abline(lm$coef[3], lm$coef[4], col = "green", lty = 2)
abline(alpha_j[1], fixef(lmm1)[2], col = "red")
abline(alpha_j[2], fixef(lmm1)[2], col = "blue")
abline(alpha_j[3], fixef(lmm1)[2], col = "green")
abline(fixef(lmm1), col = "black")
legend(6.5, 14, c("Catalonia", "Aragon", "Navarra"), col=c("blue", "green", "red"),
lty = 1, pch = 16, bty = "n", cex = 1.5)
par(op)
summary(lmm2 <- lmer(wing ~ body + (1|pop) + (0+body|pop)))
library(AHMbook)
install.packages("AHMbook")
#library(R2WinBUGS)
#bugs.dir <- "C:/WinBUGS14/"          # Place where your WinBUGS installed
library(jagsUI)
# ~~~~~ this section requires the following code from section 5.3 ~~~~~~~~~~
# Generate data with data.fn from chapter 4
set.seed(24)
data <- data.fn(show.plot=FALSE)
# Function definition with set of default values
data.fn <- function(M = 267, J = 3, mean.lambda = 2, beta1 = -2,
beta2 = 2, beta3 = 1, mean.detection = 0.3, alpha1 = 1, alpha2 = -3,
alpha3 = 0, show.plot = TRUE)
# Function definition with set of default values
data.fn <- function(M = 267, J = 3, mean.lambda = 2, beta1 = -2,
beta2 = 2, beta3 = 1, mean.detection = 0.3, alpha1 = 1, alpha2 = -3,
alpha3 = 0, show.plot = TRUE)
data <- data.fn(show.plot=FALSE)
# Function definition with set of default values
data.fn <- function(M = 267, J = 3, mean.lambda = 2, beta1 = -2,
beta2 = 2, beta3 = 1, mean.detection = 0.3, alpha1 = 1,
alpha2 = -3,alpha3 = 0, show.plot = TRUE)
)
attach(data)
# Function definition with set of default values
data.fn <- function(M = 267, J = 3, mean.lambda = 2, beta1 = -2,
beta2 = 2, beta3 = 1, mean.detection = 0.3, alpha1 = 1,
alpha2 = -3,alpha3 = 0, show.plot = TRUE)
data <- data.fn(show.plot=FALSE)
attach(data)
# Bundle data
win.data <- list(C = C, M = nrow(C), J = ncol(C), elev = elev, forest = forest,
elev.forest = elev * forest, wind = wind)
Create covariates
elev <- runif(n = M, -1, 1)                         # Scaled elevation
forest <- runif(n = M, -1, 1)                       # Scaled forest cover
wind <- array(runif(n = M*J, -1, 1), dim = c(M, J)) # Scaled wind speed
# Function definition with set of default values
data.fn <- function(M = 267, J = 3, mean.lambda = 2, beta1 = -2,
beta2 = 2, beta3 = 1, mean.detection = 0.3, alpha1 = 1,
alpha2 = -3,alpha3 = 0, show.plot = TRUE)
data <- data.fn(show.plot=FALSE)
attach(data)
M = 267
J = 3
mean.lambda = 2
beta1 = -2
beta2 = 2
beta3 = 1
mean.detection = 0.3
alpha1 = 1
alpha2 = -3
alpha3 = 0
# Create covariates
elev <- runif(n = M, -1, 1)                         # Scaled elevation
forest <- runif(n = M, -1, 1)                       # Scaled forest cover
wind <- array(runif(n = M*J, -1, 1), dim = c(M, J)) # Scaled wind speed
# Bundle data
win.data <- list(C = C, M = nrow(C), J = ncol(C), elev = elev, forest = forest,
elev.forest = elev * forest, wind = wind)
# Specify model in BUGS language
cat(file = "RE.Poisson.txt","
model {
# Priors
mu.alpha ~ dnorm(0, 0.001)                # Mean hyperparam
tau.alpha <- pow(sd.alpha, -2)
sd.alpha ~ dunif(0, 10)                   # sd hyperparam
for(k in 1:4){
alpha[k] ~ dunif(-10, 10)              # Regression params
}
# Likelihood
for (i in 1:M){
alpha0[i] ~ dnorm(mu.alpha, tau.alpha) # Random effects and hyperparams
re0[i] <- alpha0[i] - mu.alpha         # zero-centered random effects
for(j in 1:J){
C[i,j] ~ dpois(lambda[i,j])
log(lambda[i,j]) <- alpha0[i] + alpha[1] * elev[i] + alpha[2] * forest[i] +
alpha[3] * elev.forest[i] + alpha[4] * wind[i,j]
}
}
}")
# Other model run preparations
inits <- function() list(alpha0 = rnorm(M), alpha = rnorm(4)) # Inits
params <- c("mu.alpha", "sd.alpha", "alpha0", "alpha", "re0") # Params
ni <- 30000 ; nt <- 25 ; nb <- 5000 ; nc <- 3                 # MCMC settings
# Call WinBUGS or JAGS from R (ART 6-7 min) and summarize posteriors
out8 <- jags(win.data, inits, params, "RE.Poisson.txt",
n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb)
## generar datos
n.groups<-56
n.sample<-10
n<-n.groups*n.sample
pop<-gl(n=n.groups, k=n.sample)
#longitud del cuerpo (cm)
largo.original<-runif(n, 45,70)
mn<-mean(largo.original)
sd<-sd(largo.original)
largo<-(largo.original-mn)/sd
hist(length)
Xmat<-model.matrix(~pop*largo-1-largo)
Xmat
pop*largo
pop
intercept.mean<-230
intercept.sd<-20
slope.mean<-60
slope.sd<-30
intercept.effects<-rnorm(n=n.groups, mean=intercept.mean, sd=intercept.sd)
intercept.effects
slope.effects<-rnorm(n=n.groups, mean=slope.mean, sd=slope.sd)
all.effects<-c(intercept.effects,slope.effects)
lin.pred<-Xmat[,]%*%all.effects
lin.pred
mass<-lin.pred+eps
eps<-rnorm(n=n, mean=0, sd=30)
mass<-lin.pred+eps
mass
hist(mass)
xyplot(mass~largo|pop)
library(lattice)
xyplot(mass~largo|pop)
jags.data<-list(mass=as.numeric(mass), pop=as.numeric(pop),
largo=largo,ngroups=max(as.numeric(pop)), n=n)
sink("lme.model1.txt")
cat("
model{
mu.int~dnorm(0,0.001)
tau.int<-1/(sigma.int*sigma.int)
sigma.int~dunif(0,100)
beta~dnorm(0,0.001)
tau<-1/(sigma*sigma)
sigma~dunif(0,100)
#previas
for (i in 1:ngroups){
alpha[i]~dnorm(mu.int, tau.int)
}
#likelihood
for(i in 1:n){
mass[i]~dnorm(mu[i], tau)
mu[i]<- alpha[pop[i]]+beta*largo[i]
}
}
", fill=TRUE)
sink()
# datos para jags
jags.data<-list(mass=as.numeric(mass), pop=as.numeric(pop),
largo=largo,ngroups=max(as.numeric(pop)), n=n)
# inits
inits<-function(){list(alpha=rnorm(n.groups,0,2), beta=rnorm(1,1,1),
mu.int=rnorm(1,0,1), sigma.int=rlnorm(1), sigma=rlnorm(1))}
parameters<-c("alpha","beta","mu.int","sigma.int","sigma")
ni<-2000
nb<-500
nt<-2
nc<-3
out<-jags(jags.data, inits, parameters, "lme.model1.txt", n.thin = nt, n.chains = nc,
n.burnin = nb, n.iter = ni)
out
n
out
largo.original
largo
out
n
largo.pred<-seq(-2,2,1000)
pred<-array(NA,1000,56)
pred<-array(NA,dim=c(1000,56))
for(i in 1:56){
pred[,i]<-out$mean$alpha[i]+out$mean$beta*largo.pred
}
pred
matplot(largo.pred,pred)
pred
largo.pred
largo.pred
largo.pred<-seq(-2,2,,1000)
largo.pred
pred<-array(NA,dim=c(1000,56))
for(i in 1:56){
pred[,i]<-out$mean$alpha[i]+out$mean$beta*largo.pred
}
matplot(largo.pred,pred)
matplot(largo.pred,pred, col = "grey", xlab = "largo", ylab = "masa")
matplot(largo.pred,pred, col = "grey", xlab = "largo", ylab = "masa")
lines(out$mean$mu.int+out$mean$beta*largo.pred, col="black", lwd=3)
lines(largo.pred, out$mean$mu.int+out$mean$beta*largo.pred, col="black", lwd=3)
matplot(largo.pred,pred, col = "grey", xlab = "largo", ylab = "masa",type="l",lty = 1)
lines(largo.pred, out$mean$mu.int+out$mean$beta*largo.pred, col="black", lwd=3)
n
### RANDOM INTERCPTS, RANDOM SLOPES
sink("lme.model2.txt")
cat("
model{
mu.int~dnorm(0,0.001)
tau.int<-1/(sigma.int*sigma.int)
sigma.int~dunif(0,100)
mu.slope~dnorm(0,0.001)
tau.slope<-1/(sigma.slope*sigma.slope)
sigma.slope~dunif(0,100)
#previas
for (i in 1:ngroups){
alpha[i]~dnorm(mu.int, tau.int)
beta[i]~ dnorm(mu.slope, tau.slope)
}
#likelihood
for(i in 1:n){
mass[i]~dnorm(mu[i], tau)
mu[i]<- alpha[pop[i]]+beta[pop[i]]*largo[i]
}
}
", fill=TRUE)
sink()
# datos para jags
jags.data<-list(mass=as.numeric(mass), pop=as.numeric(pop),
largo=largo,ngroups=max(as.numeric(pop)), n=n)
# inits
inits<-function(){list(alpha=rnorm(n.groups,0,2), beta=rnorm(n.groups,1,1),
mu.int=rnorm(1,0,1), sigma.int=rlnorm(1), sigma=rlnorm(1))}
parameters<-c("alpha","beta","mu.int","sigma.int","sigma")
ni<-2000
nb<-500
nt<-2
nc<-3
out<-jags(jags.data, inits, parameters, "lme.model2.txt", n.thin = nt, n.chains = nc,
n.burnin = nb, n.iter = ni)
### RANDOM INTERCPTS, RANDOM SLOPES
sink("lme.model2.txt")
cat("
model{
mu.int~dnorm(0,0.001)
tau.int<-1/(sigma.int*sigma.int)
sigma.int~dunif(0,100)
mu.slope~dnorm(0,0.001)
tau.slope<-1/(sigma.slope*sigma.slope)
sigma.slope~dunif(0,100)
tau<-1/(sigma*sigma)
sigma~dunif(0,100)
#previas
for (i in 1:ngroups){
alpha[i]~dnorm(mu.int, tau.int)
beta[i]~ dnorm(mu.slope, tau.slope)
}
#likelihood
for(i in 1:n){
mass[i]~dnorm(mu[i], tau)
mu[i]<- alpha[pop[i]]+beta[pop[i]]*largo[i]
}
}
", fill=TRUE)
sink()
# datos para jags
jags.data<-list(mass=as.numeric(mass), pop=as.numeric(pop),
largo=largo,ngroups=max(as.numeric(pop)), n=n)
# inits
inits<-function(){list(alpha=rnorm(n.groups,0,2), beta=rnorm(n.groups,1,1),
mu.int=rnorm(1,0,1), sigma.int=rlnorm(1), sigma=rlnorm(1))}
parameters<-c("alpha","beta","mu.int","sigma.int","sigma")
parameters<-c("alpha","beta","mu.int","mu.slope","sigma.int","sigma.slope")
ni<-2000
nb<-500
nt<-2
nc<-3
out<-jags(jags.data, inits, parameters, "lme.model2.txt", n.thin = nt, n.chains = nc,
n.burnin = nb, n.iter = ni)
out
largo.pred<-seq(-2,2,,1000)
pred<-array(NA,dim=c(1000,56))
for(i in 1:56){
pred[,i]<-out$mean$alpha[i]+out$mean$beta[i]*largo.pred
}
matplot(largo.pred,pred, col = "grey", xlab = "largo", ylab = "masa",type="l",lty = 1)
lines(largo.pred, out$mean$mu.int+out$mean$mu.slope*largo.pred, col="black", lwd=3)
install.packages("jagsUI", lib="C:/Program Files/R/R-4.2.3/library")
######################################
### Elegir directorio de trabajo
######################################
setwd("C:\\Users\\andrea\\Documents\\GitHub\\Curso-Ocupacion23\\EjerciciosEjemplos\\Modulo6-OcupacionComunidad")
######################################
### Cargar Paquetes
######################################
library(jagsUI)    #paquete JAGS
install.packages("jagsUI", lib="C:/Program Files/R/R-4.2.3/library")
######################################
### Cargar Paquetes
######################################
library(jagsUI)    #paquete JAGS
install.packages("jagsUI")
######################################
### Cargar Paquetes
######################################
library(jagsUI)    #paquete JAGS
