# Priors
lpsi ~ dnorm(0, 0.1)
b1 ~   dnorm(0, 0.1)
p ~   dunif(0, 1)
# Ecological model, process model (true occurrence at site i)
for (i in 1:nsite) {                                           #loop sobre sitios
logit(psi[i]) <- lpsi + b1*is[i]
z[i] ~ dbin(psi[i],1)
tmp[i] <- p * z[i]
y[i] ~ dbin(tmp[i], J[i])
} #nsite
}
",fill = TRUE)
sink()
# valores iniciales
inits <- function() list(lpsi=runif(1), b1=runif(1))
# inits <- function() list(z=zst,lpsi=runif(9), b1=runif(9),
#                          mu.lpsi=runif(1),mu.b1=runif(1))
params1 <- c("lpsi", "b1", "lp")
params2 <- c("Nsite", "Nocc.fs")
# ajustes de MCMC
ni <- 10000
nt <- 10
nb <- 1000
nc <- 3
# llamar JAGS desde R
out1 = jags(roed.data,inits, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
y
## JAGS code
sink("mod_cm.jags")
cat("
model{
# Priors
lpsi ~ dnorm(0, 0.1)
b1 ~   dnorm(0, 0.1)
p ~   dunif(0, 1)
# Ecological model, process model (true occurrence at site i)
for (i in 1:nsite) {                                           #loop sobre sitios
logit(psi[i]) <- lpsi + b1*is[i]
z[i] ~ dbin(psi[i],1)
for (j in 1:4) {
tmp[i,j] <- p * z[i]
y[i,j] ~ dbern(tmp[i,j])
}
} #nsite
}
",fill = TRUE)
sink()
# llamar JAGS desde R
out1 = jags(roed.data,inits, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
## JAGS code
sink("mod_cm.jags")
cat("
model{
# Priors
lpsi ~ dnorm(0, 0.1)
b1 ~   dnorm(0, 0.1)
p ~   dnorm(0, 1)
# Ecological model, process model (true occurrence at site i)
for (i in 1:nsite) {                                           #loop sobre sitios
logit(psi[i]) <- lpsi + b1*is[i]
z[i] ~ dbin(psi[i],1)
for (j in 1:4) {
tmp[i,j] <- p * z[i]
y[i,j] ~ dbern(tmp[i,j])
}
} #nsite
}
",fill = TRUE)
sink()
# llamar JAGS desde R
out1 = jags(roed.data,inits, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
## JAGS code
sink("mod_cm.jags")
cat("
model{
# Priors
lpsi ~ dnorm(0, 0.1)
b1 ~   dnorm(0, 0.1)
p ~   dunif(0, 1)
# Ecological model, process model (true occurrence at site i)
for (i in 1:nsite) {                                           #loop sobre sitios
logit(psi[i]) <- lpsi + b1*is[i]
z[i] ~ dbin(psi[i],1)
for (j in 1:4) {
tmp[i,j] <- p * z[i]
y[i,j] ~ dbern(tmp[i,j])
}
} #nsite
}
",fill = TRUE)
sink()
# llamar JAGS desde R
out1 = jags(roed.data,inits, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
## JAGS code
sink("mod_cm.jags")
cat("
model{
# Priors
lpsi ~ dunif(0, 1)
b1 ~   dunif(0, 1)
p ~   dunif(0, 1)
# Ecological model, process model (true occurrence at site i)
for (i in 1:nsite) {                                           #loop sobre sitios
logit(psi[i]) <- lpsi + b1*is[i]
z[i] ~ dbin(psi[i],1)
for (j in 1:4) {
tmp[i,j] <- p * z[i]
y[i,j] ~ dbern(tmp[i,j])
}
} #nsite
}
",fill = TRUE)
sink()
# llamar JAGS desde R
out1 = jags(roed.data,inits, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
## JAGS code
sink("mod_cm.jags")
cat("
model{
# Priors
lpsi ~ dunif(0, 1)
b1 ~   dunif(0, 1)
p ~   dunif(0, 1)
# Ecological model, process model (true occurrence at site i)
for (i in 1:nsite) {                                           #loop sobre sitios
logit(psi[i]) <- lpsi + b1*is[i]
z[i] ~ dbern(psi[i])
for (j in 1:4) {
tmp[i,j] <- p * z[i]
y[i,j] ~ dbern(tmp[i,j])
}
} #nsite
}
",fill = TRUE)
sink()
# valores iniciales
inits <- function() list(lpsi=runif(1), b1=runif(1))
# llamar JAGS desde R
out1 = jags(roed.data,inits, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
inits <- function()
# llamar JAGS desde R
out1 = jags(roed.data,inits, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
setwd("~/Documentos/TRABAJO/Curso Ocupacion Mendoza/Git/Curso-Ocupacion23/EjerciciosEjemplos/Modulo5-OcupacionSimple")
##########################################################
##### CURSO Modelado y estimación de ocupación para  #####
#####  poblaciones y comunidades de especies bajo    #####
#####           enfoque Bayesiano.                   #####
#######      CCT Mendoza - ABRIL 2023                #####
##########################################################
###########         Ejercicio Ocupacion          #########
###########          Roedores - Matriz           #########
##########################################################
# Los datos corresponden a dos muestreos (season) de roedores realizados en la provincia
# de Cordoba. El diseño posee 50 sitios, en los cuales se coloco 1 linea con
# 20 trampas de captura viva tipo Shermann.
# Se capturaron 9 especies de roedores: Akodon azarae, A. dolores, Calomys
# laucha, C. musculinus, C. venustus, Oligorizomys flavesces, Oxymicterus rufus,
# Tylamys pallidor, Monodelphys dimidiata.
#
# Acá borramos la memoria de R, asi nos aseguramos que no haya objetos cargados
# con anterioridad
rm(list=ls(all=TRUE))
library(jagsUI)    #paquete JAGS
data<-read.csv("datos_cm.csv",header = T)
str(data)
head(data)
attach(data)
# Para poder ordenar los datos en la matriz es importante que esten todos los sitios
# por mas que no hayan capturado nada y todas las potenciales sp por sitios
# Las matrices tienen el mismo numero de filas y columnas
# Para utilizar el siguiente script, los datos deben estar ordenados primero
# por sesion y despues por especie
data.season.1 <-data[1:50,1:7]      # datos del primer muestreo
data.season.2 <-data[51:100,1:7]    # datos del segundo muestreo
# Las listas con los nombres nos van a permitir organizar luego el array
season.list<- list("1", "2")
site.list<- list("1", "2","3","4","5","6","7","8","9","10",
"11","12","13","14","15","16","17","18","19","20",
"21","22","23","24","25","26","27","28","29","30",
"31","32","33","34","35","36","37","38","39","40",
"41","42","43","44","45","46","47","48","49","50")
rep.list<- list("1", "2","3","4")
#seleccionamos solo las columnas que corresponden a los datos de conteos
# Season 1
counts.season.1 <- cbind(data.season.1$X1, data.season.1$X2, data.season.1$X3,data.season.1$X4)
DET.season.1 <- counts.season.1
DET.season.1[DET.season.1 > 1] <- 1       # transformamos los valores en datos deteccion/no deteccion
# Season 2
counts.season.2 <- cbind(data.season.2$X1, data.season.2$X2, data.season.2$X3,data.season.2$X4)
DET.season.2 <- counts.season.2
DET.season.2[DET.season.2 > 1] <- 1       # transformamos los valores en datos deteccion/no deteccion
nsite <- 50                     # numero de sitios
nrep <- 4                       # number of replicate surveys per season  - cada una de las 4 noches
nseason<-2                      # muestreos
library(abind)
y<-abind(DET.season.1,DET.season.2,along = 3)  # es 4 porque es en una dimension mas de las que ya tienen (filas, columnas y especies)
dimnames(y) <- list(site=site.list,rep= rep.list, season=season.list)  #nombres de las dimensiones
y <-DET.season.1
# Escalo la covariable
is <- (scale(data$is))
### Construyo matrices de las covariables
is<- array(is, dim = c(nsite))
dimnames(is) <- list(site=site.list)  #nombres de las dimensiones
J1<- data$J[1:nsite]
J2<- data$J[51:100]
J<-abind(matrix(J1),matrix(J2))
# ----------------
# PARTE 1
# ---------------
# creo una lista con los datos que utilizara el modelo
str(roed.data <- list(y=y, nsite=50, is = is, J=J))
## JAGS code
sink("mod_cm.jags")
cat("
model{
# Priors
lpsi ~ dunif(0, 1)
b1 ~   dunif(0, 1)
p ~   dunif(0, 1)
# Ecological model, process model (true occurrence at site i)
for (i in 1:nsite) {                                           #loop sobre sitios
logit(psi[i]) <- lpsi + b1*is[i]
z[i] ~ dbern(psi[i])
for (j in 1:4) {
tmp[i,j] <- p * z[i]
y[i,j] ~ dbern(tmp[i,j])
}
} #nsite
}
",fill = TRUE)
sink()
# valores iniciales
inits <- function()
()
# llamar JAGS desde R
out1 = jags(roed.data, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
params1 <- c("lpsi", "b1", "lp")
# ajustes de MCMC
ni <- 10000
nt <- 10
nb <- 1000
nc <- 3
# llamar JAGS desde R
out1 = jags(roed.data, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
# valores iniciales
inits <- function()list(lpsi=runif(3), b1=runif(3))
# llamar JAGS desde R
out1 = jags(roed.data, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
# llamar JAGS desde R
out1 = jags(roed.data, inits, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
# valores iniciales
inits <- function()list(lpsi=runif(1), b1=runif(1)))
# valores iniciales
inits <- function()list(lpsi=runif(1), b1=runif(1))
# llamar JAGS desde R
out1 = jags(roed.data, inits, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
## JAGS code
sink("mod_cm-mat.jags")
cat("
model{
# Priors
lpsi ~ dnorm(0, 0.01)
b1 ~   dnorm(0, 0.01)
p ~   dnorm(0, 0.01)
# Ecological model, process model (true occurrence at site i)
for (i in 1:nsite) {                                           #loop sobre sitios
psi[i] <- lpsi + b1*is[i]
z[i] ~ dbern(psi[i])
for (j in 1:4) {
tmp[i,j] <- p * z[i]
y[i,j] ~ dbern(tmp[i,j])
}
} #nsite
}
",fill = TRUE)
sink()
# valores iniciales
inits <- function()list(lpsi=runif(1), b1=runif(1))
params1 <- c("lpsi", "b1", "lp")
params2 <- c("Nsite", "Nocc.fs")
# ajustes de MCMC
ni <- 10000
nt <- 10
nb <- 1000
nc <- 3
# llamar JAGS desde R
out1 = jags(roed.data, inits, params1, "mod_cm-mat.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
## JAGS code
sink("mod_cm-mat.jags")
cat("
model{
# Priors
lpsi ~ dnorm(0, 0.01)
b1 ~   dnorm(0, 0.01)
p ~   dunif(0, 1)
# Ecological model, process model (true occurrence at site i)
for (i in 1:nsite) {                                           #loop sobre sitios
psi[i] <- lpsi + b1*is[i]
z[i] ~ dbern(psi[i])
for (j in 1:4) {
tmp[i,j] <- p * z[i]
y[i,j] ~ dbern(tmp[i,j])
}
} #nsite
}
",fill = TRUE)
sink()
# valores iniciales
inits <- function()list(lpsi=runif(1), b1=runif(1))
params1 <- c("lpsi", "b1", "lp")
params2 <- c("Nsite", "Nocc.fs")
# ajustes de MCMC
ni <- 10000
nt <- 10
nb <- 1000
nc <- 3
# llamar JAGS desde R
out1 = jags(roed.data, inits, params1, "mod_cm-mat.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
# Acá borramos la memoria de R, asi nos aseguramos que no haya objetos cargados
# con anterioridad
rm(list=ls(all=TRUE))
library(jagsUI)    #paquete JAGS
data<-read.csv("datos_cm.csv",header = T)
str(data)
head(data)
attach(data)
# creo una lista con los datos que utilizara el modelo
str(roed.data <- list(y=y, nsite=50, is = is, J=J))
## JAGS code
sink("mod_cm.jags")
cat("
model{
# Priors
lpsi ~ dnorm(0, 0.1)
b1 ~   dnorm(0, 0.1)
p ~   dunif(0, 1)
# Ecological model, process model (true occurrence at site i)
for (i in 1:nsite) {                                           #loop sobre sitios
logit(psi[i]) <- lpsi + b1*is[i]
z[i] ~ dbin(psi[i],1)
tmp[i] <- p * z[i]
y[i] ~ dbin(tmp[i], J[i])
} #nsite
}
",fill = TRUE)
sink()
# valores iniciales
inits <- function() list(lpsi=runif(1), b1=runif(1))
params1 <- c("lpsi", "b1", "p")
# ajustes de MCMC
ni <- 10000
nt <- 10
nb <- 1000
nc <- 3
# llamar JAGS desde R
out1 = jags(roed.data,inits, params1, "mod_cm.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) # con PARALLEL = TRUE esto corren cada cadena en cada nucleo entonces hace
##########################################################
##### CURSO Modelado y estimación de ocupación para  #####
#####  poblaciones y comunidades de especies bajo    #####
#####           enfoque Bayesiano.                   #####
#######      CCT Mendoza - ABRIL 2023                #####
##########################################################
###########         Ejercicio Ocupacion          #########
###########          Roedores - Vectores         #########
##########################################################
# Los datos corresponden a dos muestreos (season) de roedores realizados en la provincia
# de Cordoba. El diseño posee 50 sitios, en los cuales se coloco 1 linea con
# 20 trampas de captura viva tipo Shermann.
# Se capturaron 9 especies de roedores: Akodon azarae, A. dolores, Calomys
# laucha, C. musculinus, C. venustus, Oligorizomys flavesces, Oxymicterus rufus,
# Tylamys pallidor, Monodelphys dimidiata.
#
rm(list=ls(all=TRUE))
library(jagsUI)    #paquete JAGS
data<-read.csv("datos_roedores.csv",header = T)
setwd("~/Documentos/TRABAJO/Curso Ocupacion Mendoza/Git/Curso-Ocupacion23/EjerciciosEjemplos/Modulo6-OcupacionComunidad")
##########################################################
##### CURSO Modelado y estimación de ocupación para  #####
#####  poblaciones y comunidades de especies bajo    #####
#####           enfoque Bayesiano.                   #####
#######      CCT Mendoza - ABRIL 2023                #####
##########################################################
###########         Ejercicio Ocupacion          #########
###########          Roedores - Vectores         #########
##########################################################
# Los datos corresponden a dos muestreos (season) de roedores realizados en la provincia
# de Cordoba. El diseño posee 50 sitios, en los cuales se coloco 1 linea con
# 20 trampas de captura viva tipo Shermann.
# Se capturaron 9 especies de roedores: Akodon azarae, A. dolores, Calomys
# laucha, C. musculinus, C. venustus, Oligorizomys flavesces, Oxymicterus rufus,
# Tylamys pallidor, Monodelphys dimidiata.
#
rm(list=ls(all=TRUE))
library(jagsUI)    #paquete JAGS
data<-read.csv("datos_roedores.csv",header = T)
str(data)
head(data, 5)
data1 <- data[1:50,]
attach(data)
str(roed.data <- list(y=y, J=J,is = is, sp =sp, season = season))
### JAGS code
sink("modelo.jags")
cat("
model{
# Hyperpriors
mu.lpsi ~ dnorm(0, 1)
mu.b1 ~   dnorm(0, 1)
mu.lp ~   dnorm(0, 1)
#  p ~   dunif(0,1)
tau.lpsi <- pow(sd.lpsi,-2)
tau.lp <- pow(sd.lp,-2)
tau.b1 <- pow(sd.b1,-2)
sd.lpsi ~ dunif(0,1)
sd.lp ~ dunif(0,1)
sd.b1 ~ dunif(0,1)
for (k in 1:9) {
lpsi[k]~ dnorm(mu.lpsi, tau.lpsi)
b1[k]~ dnorm(mu.b1, tau.b1)
lp[k]~ dnorm(mu.lp, tau.lp)
}
# Likelihood
for (i in 1:900){
# Ecological model, process model (true occurrence at site i)
logit(psi[i]) <- lpsi[sp[i]] + b1[sp[i]] * is[i]
z[i] ~ dbin(psi[i],1)
## Modelo para la deteccion
logit(p[i]) <- lp[sp[i]]
tmp[i] <- p[i] * z[i]
y[i] ~ dbin(tmp[i], J[i])
}
}
",fill=TRUE)
sink()
# valores iniciales
inits <- function() list(lpsi=runif(9), b1=runif(9),
mu.lpsi=runif(1),mu.b1=runif(1))
params1 <- c("lpsi", "b1", "lp","mu.lpsi","mu.lp","mu.b1")
params2 <- c("Nsite", "Nocc.fs")
# ajustes de MCMC
ni <- 60000
nt <- 10
nb <- 10000
nc <- 3
# llamar JAGS desde R
out1= jags(roed.data,inits, params1, "modelo.jags", n.chains=nc,
n.iter=ni, n.burnin=nb, n.thin=nt) #con PARALLEL =TRUE esto corren cada cadena en cada nucleo entonces hace
library(denstrip)
plot(out1$sims.list$b1, xlim=c(-3, 3), ylim=c(1, 9), xlab="", ylab="", type="n", axes =
F, main = "Density strip plots")
axis(1)
axis(2, at = 1:9, labels = c('Aa','Ad','Cm','Cl','Cv','Of', 'Or','Md', 'Tp'), las = 1)
abline(v = c(--1,-0.5,0.5,1), col = "grey") ; abline(v = 0)
for(k in 1:9){
denstrip(unlist(out1$sims.list$b1[,k]), at = k,
colmax = "#4292c6", colmin = "#f7fbff")
}
library(jagsUI)    #paquete JAGS
# Agrupar los datos en una lista para que pueda ser leida por JAGS
data <- list(y = c(6,0,1,2,1,7,1,5,2,0))
# Modelo
sink("media.jags")
cat("
model
{
for (i in 1:10)
{
y[i] ~ dpois (m)
}
m ~ dlnorm(0.0, 1.0E-6)
}
",fill = TRUE)
sink()
#MCMC settings
ni <- 100000
nt <- 2
nb <- 10000
nc <- 3
#Parametros
parameters <- c("m")
inits <- function() list(m = 5)
out <- jags(data,
inits=inits,
parameters,
"media-poisson.jags",
n.chains = nc,
n.thin = nt,
n.iter = ni,
n.burnin = nb)
out <- jags(data,
inits=inits,
parameters,
"media.jags",
n.chains = nc,
n.thin = nt,
n.iter = ni,
n.burnin = nb)
