######################################
### Borrar documentacion anterior de R
######################################
rm(list=ls(all=TRUE))
######################################
### Elegir directorio de trabajo
######################################
setwd("C:\\Users\\andrea\\Documents\\GitHub\\Curso-Ocupacion23\\EjerciciosEjemplos\\Modulo6-OcupacionComunidad")
######################################
### Cargar Paquetes
######################################
library(jagsUI)    #paquete JAGS
######################################
### Procesamiento de Datos
######################################
## Datos del Swiss breeding bird survey MHB
# Leemos los datos y los revisamos
data <- read.csv("MHB_2014.csv", header = T, sep = ",", dec= ".")
str(data)
head(data)
dim(data)
# Ac? crean varias listas de especies (basadas en los nombres en ingl?s y ordenes)
species.list <- levels(as.factor(data$engname))   # lista por orden alfab?tico
spec.name.list <- tapply(data$specid, data$engname, mean) # ID de las especies
spec.id.list <- unique(data$specid)    # lista ID
ordered.spec.name.list <- spec.name.list[order(spec.name.list)] # lista de ID en orden
DET <- cbind(data$count141, data$count142, data$count143)  # Conteos
DET[DET > 1] <- 1       # Todo lo que es mayor a 1, lo convierto en 1 (datos para detecci?n/no detecci?n)
# Ponen los datos de deteccion en en arreglo 3D: sitio x rep x especie
nsite <- 267                    # numero de sitios en Swiss MHB
nrep <- 3                       # numero de repeticiones por temporada
setwd("~/Documentos/TRABAJO/Curso Ocupacion Mendoza/Git/Curso-Ocupacion23/EjerciciosEjemplos/Modulo6-OcupacionComunidad")
######################################
### Cargar Paquetes
######################################
library(jagsUI)    #paquete JAGS
######################################
### Procesamiento de Datos
######################################
## Datos del Swiss breeding bird survey MHB
# Leemos los datos y los revisamos
data <- read.csv("MHB_2014.csv", header = T, sep = ",", dec= ".")
str(data)
head(data)
dim(data)
# Ac? crean varias listas de especies (basadas en los nombres en ingl?s y ordenes)
species.list <- levels(as.factor(data$engname))   # lista por orden alfab?tico
spec.name.list <- tapply(data$specid, data$engname, mean) # ID de las especies
spec.id.list <- unique(data$specid)    # lista ID
ordered.spec.name.list <- spec.name.list[order(spec.name.list)] # lista de ID en orden
DET <- cbind(data$count141, data$count142, data$count143)  # Conteos
DET[DET > 1] <- 1       # Todo lo que es mayor a 1, lo convierto en 1 (datos para detecci?n/no detecci?n)
# Ponen los datos de deteccion en en arreglo 3D: sitio x rep x especie
nsite <- 267                    # numero de sitios en Swiss MHB
nrep <- 3                       # numero de repeticiones por temporada
nspec <- length(species.list)   # 83 especies
# armo el array para meter el loop
Y <- array(NA, dim = c(nsite, nrep, nspec))
for(i in 1:nspec){
Y[,,i] <- DET[((i-1)*nsite+1):(i*nsite),]
}
dimnames(Y) <- list(NULL, NULL, names(ordered.spec.name.list))
# Chequear los datos de una especie y "llamarlos" del array 3D
which(names(ordered.spec.name.list) == "Common Rosefinch")
tmp <- Y[,,which(names(ordered.spec.name.list) == "Common Rosefinch")]
dim(tmp)
# Distribucion de frecuencias de numero de muestreos por sitio
# aqui veo que 1 sitio no tuvo muestreos
table(nsurveys <- apply(Y[,,1], 1, function(x) sum(!is.na(x))))
# Con esto identifico cual es el sitio que no tuvo muestreo
(NAsites <- which(nsurveys == 0) )
# Numero de especies observadas por sitio
tmp <- apply(Y, c(1,3), max, na.rm = TRUE)
tmp[tmp == "-Inf"] <- NA
sort(C <- apply(tmp, 1, sum))     # Compute and print sorted species counts
par(mfrow=c(1,1))
plot(table(C), xlim = c(0, 40), xlab = "Numero de especies observadas",
ylab = "Numero de cuadrantes", frame = F)
abline(v = mean(C, na.rm = TRUE), col = "blue", lwd = 3)
# Colapsar los datos 3D de deteccion/no deteccion a frecuencias de deteccion 2D
Ysum <- apply(Y, c(1,3), sum, na.rm = T) #
Ysum[NAsites,] <- NA                     # los que tienen sitios NA, ponerles NA
# Aumentar set de datos (DA - data augmentation)
nz <- 30                # Numero de especies potenciales en la superpoblacion
M <- nspec + nz          # Tama?o del data set aumentado ('superpoblacion')
Yaug <- cbind(Ysum, array(0, dim=c(nsite, nz))) # Agregar historias con ceros
# unir y llamar al set de datos
str( win.data <- list(Yaug = Yaug, nsite = nrow(Ysum), nrep = data$nsurvey[1:nsite], M = M, nspec = nspec, nz = nz) )
# Especificar el modelo en lenguaje JAGS
sink("modelDA.txt")
cat("
model {
# Previas de la comunidad
for(k in 1:M){                  # Loop sobre especies
lpsi[k] ~ dnorm(mu.lpsi, tau.lpsi)
lp[k] ~ dnorm(mu.lp, tau.lp)
}
# Hiperprevias de community
omega ~ dunif(0,1)
mu.lpsi ~ dnorm(0,0.001)
mu.lp ~ dnorm(0,0.001)
tau.lpsi <- pow(sd.lpsi, -2)
sd.lpsi ~ dunif(0,5)
tau.lp <- pow(sd.lp, -2)
sd.lp ~ dunif(0,5)
# proceso de superpoblacion
for(k in 1:M){
w[k] ~ dbern(omega)           # indicador de pertenencia a la metacomunidad
}
# Modelo ecologico
for(k in 1:M){
mu.psi[k] <- w[k] * psi[k]    # las especies que no son parte de la comunidad obtienen un cero w
logit(psi[k]) <- lpsi[k]
for (i in 1:nsite) {
z[i,k] ~ dbern(mu.psi[k])
}
}
# Modelo de obsevacion
for(k in 1:M){
logit(p[k]) <- lp[k]
for (i in 1:nsite) {
mu.p[i,k] <- z[i,k] * p[k]  # las especies que no ocurren tienen 0 en z
Yaug[i,k] ~ dbin(mu.p[i,k], nrep[i])
}
}
# Derived quantities
for(k in 1:M){
Nocc.fs[k] <- sum(z[,k])     # Number of occupied sites among the 267
}
for (i in 1:nsite) {
Nsite[i] <- sum(z[i,])       # Number of occurring species at each site
}
n0 <- sum(w[(nspec+1):(nspec+nz)]) # Number of unseen species in metacommunity
Ntotal <- sum(w[])              # Total metacommunity size (= nspec + n0)
}
",fill = TRUE)
sink()
# Valores iniciales
wst <- rep(1, nspec+nz)                   # Setear todos a ocurrencia 1
zst <- array(1, dim = c(nsite, nspec+nz)) # lo mimso para z
inits <- function() list(z = zst, w = wst, lpsi = rnorm(n = nspec+nz), lp = rnorm(n = nspec+nz))
# Parametros monitoreados
params <- c("mu.lpsi", "mu.lp", "psi", "p", "Nsite", "Ntotal", "omega", "n0")
# seteos de MCMC
ni <- 7000   ;   nt <- 10  ;   nb <- 100   ;   nc <- 3;   na <- 3000
# Llamar a las covariables y estandarizarlas
# Elevacion y cobertura de bosque
orig.ele <- data$elev[1:nsite]
(mean.ele <- mean(orig.ele, na.rm = TRUE))
(sd.ele <- sd(orig.ele, na.rm = TRUE))
ele <- (orig.ele - mean.ele) / sd.ele
orig.forest <- data$forest[1:nsite]
(mean.forest <- mean(orig.forest, na.rm = TRUE))
(sd.forest <- sd(orig.forest, na.rm = TRUE))
forest <- (orig.forest - mean.forest) / sd.forest
# Get survey date and survey duration and standardise both
# Survey date (this is Julian date, with day 1 being April 1)
orig.DAT <- cbind(data$date141, data$date142, data$date143)[1:nsite,]
(mean.date <- mean(orig.DAT, na.rm = TRUE))
(sd.date <- sd(c(orig.DAT), na.rm = TRUE))
DAT <- (orig.DAT - mean.date) / sd.date      # scale
DAT[is.na(DAT)] <- 0                         # impute missings
# Survey duration (in minutes)
orig.DUR <- cbind(data$dur141, data$dur142, data$dur143)[1:nsite,]
(mean.dur <- mean(orig.DUR, na.rm = TRUE))
(sd.dur <- sd(c(orig.DUR), na.rm = TRUE))
DUR <- (orig.DUR - mean.dur) / sd.dur        # scale
DUR[is.na(DUR)] <- 0                         # mean impute missings
nz <- 250                 # Use for vague prior on Ntotal: M = 395
nz <- 215 - nspec         # Use for informative prior on Ntotal: M = 215
Yaug <- array(0, dim=c(nsite, nrep, nspec+nz)) # array with only zeroes
Yaug[,,1:nspec] <- Y      # copy into it the observed data
# Create same NA pattern in augmented species as in the observed species
missings <- is.na(Yaug[,,1]) # e.g., third survey in high-elevation quads
for(k in (nspec+1):(nspec+nz)){
Yaug[,,k][missings] <- NA
}
# Bundle and summarize data
str(win.data <- list(Y = Yaug, nsite = dim(Y)[1], nrep = dim(Y)[2], nspec = dim(Y)[3],
nz = nz, M = nspec + nz, ele = ele, forest = forest, DAT = DAT, DUR = DUR) )
# Specify model in BUGS language
sink("model10.txt")
cat("
model {
# Priors
omega ~ dunif(0,1)
# Priors for species-specific effects in occupancy and detection
for(k in 1:M){
lpsi[k] ~ dnorm(mu.lpsi, tau.lpsi)    # Hyperparams describe community
betalpsi1[k] ~ dnorm(mu.betalpsi1, tau.betalpsi1)
betalpsi2[k] ~ dnorm(mu.betalpsi2, tau.betalpsi2)
betalpsi3[k] ~ dnorm(mu.betalpsi3, tau.betalpsi3)
lp[k] ~ dnorm(mu.lp, tau.lp)
betalp1[k] ~ dnorm(mu.betalp1, tau.betalp1)
betalp2[k] ~ dnorm(mu.betalp2, tau.betalp2)
betalp3[k] ~ dnorm(mu.betalp3, tau.betalp3)
}
# Hyperpriors
# For the model of occupancy
mu.lpsi ~ dnorm(0,0.01)
tau.lpsi <- pow(sd.lpsi, -2)
sd.lpsi ~ dunif(0,8)   # as always, bounds of uniform chosen by trial and error
mu.betalpsi1 ~ dnorm(0,0.1)
tau.betalpsi1 <- pow(sd.betalpsi1, -2)
sd.betalpsi1 ~ dunif(0, 4)
mu.betalpsi2 ~ dnorm(0,0.1)
tau.betalpsi2 <- pow(sd.betalpsi2, -2)
sd.betalpsi2 ~ dunif(0,2)
mu.betalpsi3 ~ dnorm(0,0.1)
tau.betalpsi3 <- pow(sd.betalpsi3, -2)
sd.betalpsi3 ~ dunif(0,2)
# For the model of detection
mu.lp ~ dnorm(0,0.1)
tau.lp <- pow(sd.lp, -2)
sd.lp ~ dunif(0, 2)
mu.betalp1 ~ dnorm(0,0.1)
tau.betalp1 <- pow(sd.betalp1, -2)
sd.betalp1 ~ dunif(0,1)
mu.betalp2 ~ dnorm(0,0.1)
tau.betalp2 <- pow(sd.betalp2, -2)
sd.betalp2 ~ dunif(0,1)
mu.betalp3 ~ dnorm(0,0.1)
tau.betalp3 <- pow(sd.betalp3, -2)
sd.betalp3 ~ dunif(0,1)
# Superpopulation process: Ntotal species sampled out of M available
for(k in 1:M){
w[k] ~ dbern(omega)
}
# Ecological model for true occurrence (process model)
for(k in 1:M){
for (i in 1:nsite) {
logit(psi[i,k]) <- lpsi[k] + betalpsi1[k] * ele[i] +
betalpsi2[k] * pow(ele[i],2) + betalpsi3[k] * forest[i]
mu.psi[i,k] <- w[k] * psi[i,k]
z[i,k] ~ dbern(mu.psi[i,k])
}
}
# Observation model for replicated detection/nondetection observations
for(k in 1:M){
for (i in 1:nsite){
for(j in 1:nrep){
logit(p[i,j,k]) <- lp[k] + betalp1[k] * DAT[i,j] +
betalp2[k] * pow(DAT[i,j],2) + betalp3[k] * DUR[i,j]
mu.p[i,j,k] <- z[i,k] * p[i,j,k]
Y[i,j,k] ~ dbern(mu.p[i,j,k])
}
}
}
# Derived quantities
#for(k in 1:M){
#   Nocc.fs[k] <- sum(z[,k])       # Number of occupied sites among the 267
#}
for (i in 1:nsite){
Nsite[i] <- sum(z[i,])          # Number of occurring species at each site
}
n0 <- sum(w[(nspec+1):(nspec+nz)]) # Number of unseen species
Ntotal <- sum(w[])                 # Total metacommunity size
# Vectors to save (S for ?save?; discard posterior samples for
# all minus 1 of the potential species to save disk space)
# we do this for nz = 250 (i.e., M = 395)
lpsiS[1:(nspec+1)] <- lpsi[1:(nspec+1)]
betalpsi1S[1:(nspec+1)] <- betalpsi1[1:(nspec+1)]
betalpsi2S[1:(nspec+1)] <- betalpsi2[1:(nspec+1)]
betalpsi3S[1:(nspec+1)] <- betalpsi3[1:(nspec+1)]
lpS[1:(nspec+1)] <- lp[1:(nspec+1)]
betalp1S[1:(nspec+1)] <- betalp1[1:(nspec+1)]
betalp2S[1:(nspec+1)] <- betalp2[1:(nspec+1)]
betalp3S[1:(nspec+1)] <- betalp3[1:(nspec+1)]
}
",fill = TRUE)
sink()
# Initial values
wst <- rep(1, nspec+nz)                   # Simply set everybody at occurring
zst <- array(1, dim = c(nsite, nspec+nz)) # ditto
inits <- function() list(z = zst, w = wst, lpsi = rnorm(n = nspec+nz), betalpsi1 = rnorm(n = nspec+nz), betalpsi2 = rnorm(n = nspec+nz), betalpsi3 = rnorm(n = nspec+nz), lp = rnorm(n = nspec+nz), betalp1 = rnorm(n = nspec+nz), betalp2 = rnorm(n = nspec+nz), betalp3 = rnorm(n = nspec+nz))
# Set 1
params1 <- c("omega", "mu.lpsi", "sd.lpsi", "mu.betalpsi1", "sd.betalpsi1", "mu.betalpsi2", "sd.betalpsi2", "mu.betalpsi3", "sd.betalpsi3", "mu.lp", "sd.lp", "mu.betalp1", "sd.betalp1", "mu.betalp2", "sd.betalp2", "mu.betalp3", "sd.betalp3", "Ntotal", "Nsite")
# MCMC settings
ni <- 100   ;   nt <- 2   ;   nb <- 10   ;   nc <- 3
out102 <- jags.basic(win.data, inits, params2, "model10.txt", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, parallel = TRUE)
# Set 2
params2 <- c("mu.lpsi", "sd.lpsi", "mu.betalpsi1", "sd.betalpsi1", "mu.betalpsi2", "sd.betalpsi2", "mu.betalpsi3", "sd.betalpsi3", "lpsi", "betalpsi1", "betalpsi2", "betalpsi3", "lp", "betalp1", "betalp2", "betalp3", "z", "w")
ni <- 12000   ;   nt <- 20   ;   nb <- 2000   ;   nc <- 3
out102 <- jags.basic(win.data, inits, params2, "model10.txt", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, parallel = TRUE)
