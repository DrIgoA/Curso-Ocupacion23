library(jagsUI)    #paquete JAGS
out
str(out)
traceplot(out, parameters=c("mean", "varianza"))
library(jagsUI)    #paquete JAGS
library(jagsUI)    #paquete JAGS
library(jagsUI)    #paquete JAGS
library(jagsUI)    #paquete JAGS
#Ejemplo tamaño medio de zorzales (n=10)
data <- list(size = c(7.9,8.1,11,10.6,9.2,8,9.8,10.1,10.9,9))
sink("zorzales.jags")
cat("
model
{
# previas no informativas
mean ~ dnorm (0, 1.0E-6)  # tamaño medio de los zorzales
varianza ~ dlnorm (0 ,1.0E-6)  # varianza tamaño zorzales
prec <- 1/varianza             # pasar de varianza a precision
for (i in 1:10)            # para cada uno de los Zorzales
{
size[i] ~ dnorm (mean, prec)   # tamaño zorzal trazado de una distribución normal
}
}
",fill = TRUE)
sink()
inits <- function() list(varianza=100, mean = 10)
# MCMC settings
ni <- 10000  # número de iteraciones
nt <- 2      # tasa de thining
nb <- 1000   # iteraciones para el burn in
nc <- 3      # número de cadenas que corremos
parameters <- c("mean", "varianza")
out <- jags(data, inits, parameters, "zorzales.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb)
out
str(out)
plot(out)
traceplot(out, parameters=c("mean", "varianza"))
library(jagsUI)    #paquete JAGS
#Ejemplo tamaño medio de zorzales (n=10)
data <- list(size = c(7.9,8.1,11,10.6,9.2,8,9.8,10.1,10.9,9))
sink("zorzales.jags")
cat("
model
{
# previas no informativas
mean ~ dnorm (0, 1.0E-6)  # tamaño medio de los zorzales
varianza ~ dlnorm (0 ,1.0E-6)  # varianza tamaño zorzales
prec <- 1/varianza             # pasar de varianza a precision
for (i in 1:10)            # para cada uno de los Zorzales
{
size[i] ~ dnorm (mean, prec)   # tamaño zorzal trazado de una distribución normal
}
}
",fill = TRUE)
sink()
inits <- function() list(varianza=100, mean = 10)
# MCMC settings
ni <- 10000  # número de iteraciones
nt <- 2      # tasa de thining
nb <- 1000   # iteraciones para el burn in
nc <- 3      # número de cadenas que corremos
parameters <- c("mean", "varianza")
out <- jags(data, inits, parameters, "zorzales.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb)
out
str(out)
plot(out)
traceplot(out, parameters=c("mean", "varianza"))
plot(out)
plot(out)
traceplot(out, parameters=c("mean", "varianza"))
density(out, parameters=c("mean", "varianza"))
densityply(out, parameters=c("mean", "varianza"))
densityplot(out, parameters=c("mean", "varianza"))
setwd("C:\\Users\\andrea\\Documents\\GitHub\\Curso-Ocupacion23\\Bayes")
###################################################
### Cargar Paquete
###################################################
library(jagsUI)    #paquete JAGS
# Simulacion de datos
data.fn <- function(n = 40, alpha = 3.5576, beta1 = -0.0912, beta2 = 0.0091, beta3 = -0.00014){
# n: Number of years
# alpha, beta1, beta2, beta3: coeficientes de un polinomio cubico de conteos anuales
# Genera valores de cova en el tiempo
year <- 1:n
# Parte del GLM
log.expected.count <- alpha + beta1 * year + beta2 * year^2 + beta3 * year^3
expected.count <- exp(log.expected.count)
# Ruido: genera parte aleatoria del GLM: Ruido Poisson alrededor de los puntos
C <- rpois(n = n, lambda = expected.count)
# Plot simulated data
plot(year, C, type = "b", lwd = 2, col = "black", main = "", las = 1, ylab = "Population size", xlab = "Year", cex.lab = 1.2, cex.axis = 1.2)
lines(year, expected.count, type = "l", lwd = 3, col = "red")
return(list(n = n, alpha = alpha, beta1 = beta1, beta2 = beta2, beta3 = beta3, year = year, expected.count = expected.count, C = C))
}
data <- data.fn()
##############################
#####  DATOS            ######
##############################
C = data$C
n = length(data$C)
raw.year = data$year
##############################
#####  GLM Poisson      ######
##############################
fm <- glm(C ~ year + I(year^2) + I(year^3), family = poisson, data = data)
summary(fm)
# Especificar modelo en JAGS
sink("GLM_Poisson.jags")
cat("
model {
# Priors
alpha ~ dunif(-20, 20)
beta1 ~ dunif(-10, 10)
beta2 ~ dunif(-10, 10)
beta3 ~ dunif(-10, 10)
# Verosimilitud: Componentes clave de un GLM en cada linea
for (i in 1:n){                       #desde 1 hasta n observaciones (n=40)
C[i] ~ dpois(lambda[i])          # 1. Distribucion de parte aleatoria
log(lambda[i]) <- log.lambda[i]  # 2. Funcion de enlace (Link function)
log.lambda[i] <- alpha + beta1 * year[i] + beta2 * pow(year[i],2) + beta3 * pow(year[i],3)   # 3. Predictor Lineal
} #i
}
",fill = TRUE)
sink()
# Unir datos
# con variable estandarizada!
mean.year <- mean(data$year)             # Mean of year covariate
sd.year <- sd(data$year)                 # SD of year covariate
win.data <- list(C = data$C, n = length(data$C), year = (data$year - mean.year) / sd.year)
# Valores iniciales
inits <- function() list(alpha = runif(1, -2, 2), beta1 = runif(1, -3, 3))
# Parametros monitoreados
params <- c("alpha", "beta1", "beta2", "beta3", "lambda")
# MCMC settings
ni <- 10000
nt <- 2
nb <- 1000
nc <- 3
# Call JAGS from R (BRT < 1 min)
out <- jags(data = win.data, inits = inits, parameters.to.save = params, model.file = "GLM_Poisson.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb)
print(out, dig = 3)
plot(out)
plot(1:40, data$C, type = "b", lwd = 2, col = "black", main = "", las = 1, ylab = "Population size", xlab = "Year")
R.predictions <- predict(glm(C ~ year + I(year^2) + I(year^3), family = poisson, data = data), type = "response")
lines(1:40, R.predictions, type = "l", lwd = 3, col = "green")
out$mean$lambda
JAGS.predictions <- out$mean$lambda
lines(1:40, JAGS.predictions, type = "l", lwd = 3, col = "blue", lty = 2)
cbind(R.predictions, JAGS.predictions)
plot(density(rbeta(n=10^6, shape1=2, shape2 = 4)))
hist(rbeta(10^6, 2, 4), nclass=100, col="gray")
rbeta(n=10^6, shape1=2, shape2 = 4)
dbeta(n=10^6, shape1=2, shape2 = 4)
qbeta(n=10^6, shape1=2, shape2 = 4)
hist(rpois(10^6, 2), nclass=100, col="gray")
hist(rpois(10^6, 4), nclass=100, col="gray")
hist(rpois(10^6, 6), nclass=100, col="gray")
### ¿Cómo se vería un histograma con poisson, y con binomial?
hist(rbinom(10^6,1, 6), nclass=100, col="gray")
?ddist
?ddist
??ddist
??dpois
?dpois
?dpois
?dbinom
?rpois
